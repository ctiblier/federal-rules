---
import '../styles/global.css';
import RuleSidebar from '../components/RuleSidebar.astro';
import Header from '../components/Header.astro';

interface Props {
  title: string;
  description?: string;
  ruleset?: 'civil' | 'criminal' | 'appellate' | 'evidence' | 'bankruptcy';
  noSidebar?: boolean;
  noIndex?: boolean;
}

const {
  title,
  description = 'Federal Rules of Civil and Criminal Procedure — professional reference for attorneys and law students.',
  ruleset,
  noSidebar = false,
  noIndex = false,
} = Astro.props;

const RULESET_FULL_NAMES: Record<string, string> = {
  civil:      'Federal Rules of Civil Procedure',
  criminal:   'Federal Rules of Criminal Procedure',
  appellate:  'Federal Rules of Appellate Procedure',
  evidence:   'Federal Rules of Evidence',
  bankruptcy: 'Federal Rules of Bankruptcy Procedure',
};

// Show a breadcrumb on rule pages (not on the ruleset index itself).
const isRulesetIndex = ruleset != null && new RegExp(`^/${ruleset}/?$`).test(Astro.url.pathname);
const showBreadcrumb = ruleset != null && !isRulesetIndex;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content={description} />
    <title>{title === 'Federal Rules' ? title : `${title} | Federal Rules`}</title>
    <link rel="canonical" href={new URL(Astro.url.pathname, Astro.site).toString()} />
    <meta property="og:title" content={title === 'Federal Rules' ? title : `${title} | Federal Rules`} />
    <meta property="og:description" content={description} />
    <meta property="og:url" content={new URL(Astro.url.pathname, Astro.site).toString()} />
    <meta property="og:type" content="article" />
    <meta property="og:site_name" content="Federal Rules" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content={title === 'Federal Rules' ? title : `${title} | Federal Rules`} />
    <meta name="twitter:description" content={description} />
    {noIndex && <meta name="robots" content="noindex, follow" />}
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
  </head>
  <body class="min-h-screen" style="background-color: #f8f5f0;">

    <!-- Skip to main content link (accessibility - WCAG 2.4.1) -->
    <a
      href="#main-content"
      id="skip-link"
      style="position: absolute; left: -9999px; top: auto; width: 1px; height: 1px; overflow: hidden; z-index: 100; font-family: system-ui, sans-serif; font-size: 0.875rem; font-weight: 500;"
    >
      Skip to main content
    </a>
    <style>
      /* Scoped: only applies to template elements that get the Astro scope attr */
      .breadcrumb-link:hover,
      .breadcrumb-link:focus-visible {
        opacity: 1 !important;
      }
      #skip-link:focus {
        position: fixed;
        left: 50%;
        transform: translateX(-50%);
        top: 1rem;
        width: auto;
        height: auto;
        overflow: visible;
        background-color: #1a2744;
        color: white;
        padding: 0.5rem 1rem;
        border-radius: 0.375rem;
        text-decoration: none;
      }
    </style>
    <style is:global>
      /* Global: applies to JS-created elements and third-party components */

      /* Cross-reference links */
      .rule-xref {
        color: #1a2744 !important;
        font-weight: 600 !important;
        text-decoration: underline !important;
        text-decoration-style: dotted !important;
        text-underline-offset: 3px !important;
        text-decoration-color: rgba(26,39,68,0.55) !important;
        cursor: pointer;
      }
      .rule-xref:hover {
        color: #8b5c08 !important;
        text-decoration-style: solid !important;
        text-decoration-color: #c9a84c !important;
      }
      .rule-xref:focus-visible {
        outline: 2px solid #c9a84c;
        outline-offset: 2px;
        border-radius: 2px;
      }

      /* Search sticky: non-sticky on mobile so results scroll naturally */
      @media (max-width: 767px) {
        .search-sticky { position: static !important; top: auto !important; }
      }

      /* Back to top — always in layout, fades in/out */
      #back-to-top {
        position: fixed;
        bottom: 1.5rem;
        right: 1.5rem;
        z-index: 40;
        width: 2.75rem;
        height: 2.75rem;
        border-radius: 50%;
        background: #1a2744;
        color: #c9a84c;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 10px rgba(0,0,0,0.25);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s, transform 0.15s;
      }
      #back-to-top.is-visible {
        opacity: 1;
        pointer-events: auto;
      }
      #back-to-top:hover { transform: translateY(-2px); }
      #back-to-top:focus-visible { outline: 2px solid #c9a84c; outline-offset: 2px; }

      /* Deadline paragraph — base class (just primes border-radius for animation) */
      .deadline-para { border-radius: 3px; }

      /* Blink then settle to faint gold — applied when badge is clicked */
      @keyframes dl-blink {
        0%   { background-color: transparent; }
        15%  { background-color: rgba(201, 168, 76, 0.28); }
        38%  { background-color: rgba(201, 168, 76, 0.10); }
        58%  { background-color: rgba(201, 168, 76, 0.24); }
        78%  { background-color: rgba(201, 168, 76, 0.10); }
        100% { background-color: rgba(201, 168, 76, 0.14); }
      }
      .deadline-active {
        animation: dl-blink 2.4s ease-out forwards;
        border-radius: 3px;
      }

      /* Cross-ref panel: blink the target subsection to draw the eye */
      @keyframes rp-blink {
        0%   { background-color: transparent; }
        12%  { background-color: rgba(201, 168, 76, 0.28); }
        28%  { background-color: transparent; }
        48%  { background-color: rgba(201, 168, 76, 0.18); }
        65%  { background-color: transparent; }
        80%  { background-color: rgba(201, 168, 76, 0.08); }
        100% { background-color: transparent; }
      }
      .rp-highlight {
        animation: rp-blink 2s ease-out;
        border-radius: 3px;
      }
    </style>

    {!noSidebar && (
      <!-- Mobile sidebar toggle -->
      <button
        id="sidebar-toggle"
        aria-label="Open rule navigation"
        aria-expanded="false"
        aria-controls="rule-sidebar"
        class="fixed top-3 left-3 z-50 p-2 rounded shadow-md md:hidden"
        style="background-color: #1a2744; color: white; min-width: 44px; min-height: 44px;"
      >
        <svg width="18" height="18" viewBox="0 0 18 18" fill="none" aria-hidden="true">
          <path d="M2 4.5h14M2 9h14M2 13.5h14" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
        </svg>
      </button>
    )}

    {!noSidebar && (
      <!-- Mobile overlay -->
      <div
        id="sidebar-overlay"
        class="fixed inset-0 z-30 hidden md:hidden"
        style="background-color: rgba(0,0,0,0.5);"
        aria-hidden="true"
      ></div>
    )}

    <div class="flex min-h-screen">
      {!noSidebar && (
        <!-- Left sidebar: fixed on mobile, sticky on desktop -->
        <aside
          id="rule-sidebar"
          class="fixed top-0 left-0 h-full w-[260px] z-40 overflow-y-auto
                 -translate-x-full transition-transform duration-200
                 md:sticky md:translate-x-0 md:top-0 md:h-screen md:shrink-0"
          style="background-color: #1a2744; color: white;"
          aria-label="Rule navigation"
        >
          {ruleset && <RuleSidebar ruleset={ruleset} />}
        </aside>
      )}

      <!-- Main content column -->
      <div class="flex-1 min-w-0 flex flex-col">
        <Header noSearch={noSidebar} />
        <main id="main-content" tabindex="-1">
          {showBreadcrumb && (
            <nav aria-label="Breadcrumb" class="px-4 sm:px-6 pt-4 pb-0">
              <a
                href={`/${ruleset}/`}
                class="breadcrumb-link"
                style="display: inline-flex; align-items: center; gap: 0.375rem; font-size: 0.75rem; font-weight: 600; font-family: system-ui, sans-serif; color: #1a2744; text-decoration: none; opacity: 0.7; transition: opacity 0.15s;"
              >
                <svg width="12" height="12" viewBox="0 0 12 12" fill="none" aria-hidden="true">
                  <path d="M7.5 2L3.5 6l4 4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                {RULESET_FULL_NAMES[ruleset]}
              </a>
            </nav>
          )}
          <slot />
        </main>
      </div>
    </div>

    <!-- Screen-reader announcement region for cite copy and other actions -->
    <div id="sr-announce" class="sr-only" aria-live="polite" aria-atomic="true"
      style="position:absolute;width:1px;height:1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;"></div>

    <!-- Back to top button -->
    <button
      id="back-to-top"
      type="button"
      aria-label="Back to top"
    >
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true">
        <path d="M8 13V3M3 8l5-5 5 5" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </button>

    <script>
      // ── Back to top ───────────────────────────────────────────────────────
      const btt = document.getElementById('back-to-top') as HTMLButtonElement | null;
      if (btt) {
        window.addEventListener('scroll', () => {
          btt.classList.toggle('is-visible', window.scrollY > 200);
        }, { passive: true });
        btt.addEventListener('click', () => {
          const motion = window.matchMedia('(prefers-reduced-motion: reduce)').matches ? 'auto' : 'smooth';
          window.scrollTo({ top: 0, behavior: motion as ScrollBehavior });
        });
      }

      // ── Ruleset filter indicator on ruleset index pages ───────────────────
      // Shows "Searching: Civil Procedure" above the search box so users know results are pre-filtered.
      const INDEX_LABELS: Record<string, string> = {
        civil: 'Civil Procedure',
        criminal: 'Criminal Procedure',
        appellate: 'Appellate Procedure',
        evidence: 'Evidence',
        bankruptcy: 'Bankruptcy Procedure',
      };
      const indexMatch = window.location.pathname.match(/^\/(civil|criminal|appellate|evidence|bankruptcy)\/?$/);
      if (indexMatch) {
        const rs = indexMatch[1];
        const searchSection = document.getElementById('search');
        if (searchSection && INDEX_LABELS[rs]) {
          const indicator = document.createElement('p');
          indicator.style.cssText =
            'font-size:0.75rem;font-family:system-ui,sans-serif;color:#1a2744;' +
            'font-weight:600;margin-bottom:0.5rem;display:flex;align-items:center;gap:0.375rem;';
          indicator.innerHTML =
            `<span style="display:inline-block;width:0.5rem;height:0.5rem;border-radius:50%;background:#1a2744;flex-shrink:0;" aria-hidden="true"></span>` +
            `Searching: ${INDEX_LABELS[rs]}`;
          searchSection.insertAdjacentElement('afterbegin', indicator);
        }
      }

      // ── Cross-reference auto-linking + side-by-side panel ────────────────
      // Only runs on rule pages (pages with .rule-body). Exits early otherwise.
      const ruleBody = document.querySelector<HTMLElement>('.rule-body');
      if (ruleBody) {
        const ruleset = window.location.pathname.split('/').filter(Boolean)[0] ?? '';
        const RULESETS: Record<string, string> = {
          civil: 'Civil Procedure',
          criminal: 'Criminal Procedure',
          appellate: 'Appellate Procedure',
          evidence: 'Evidence',
          bankruptcy: 'Bankruptcy Procedure',
        };

        if (RULESETS[ruleset]) {
          // Reuse the global screen-reader live region for panel state announcements
          const srAnnounce = document.getElementById('sr-announce')!;

          // ── Reference panel ─────────────────────────────────────────────
          const panel = document.createElement('aside');
          panel.id = 'rule-ref-panel';
          panel.setAttribute('role', 'region');
          panel.setAttribute('aria-label', 'Referenced rule');
          panel.setAttribute('tabindex', '-1');
          panel.style.cssText =
            'position:fixed;right:0;top:0;height:100vh;width:min(46vw,640px);z-index:35;' +
            'background:#f8f5f0;border-left:1px solid rgba(28,28,30,0.15);' +
            'box-shadow:-4px 0 24px rgba(0,0,0,0.1);overflow-y:auto;display:none;';
          panel.innerHTML = `
            <div id="rp-header" style="position:sticky;top:0;z-index:1;
              background:rgba(248,245,240,0.95);backdrop-filter:blur(8px);
              border-bottom:1px solid rgba(28,28,30,0.1);
              padding:0.875rem 1.25rem;display:flex;align-items:flex-start;
              justify-content:space-between;gap:0.75rem;">
              <div style="min-width:0;">
                <p id="rp-ruleset" style="font-size:0.625rem;font-weight:700;letter-spacing:0.1em;
                  text-transform:uppercase;color:#6b7280;font-family:system-ui,sans-serif;
                  margin-bottom:0.2rem;"></p>
                <p id="rp-title" style="font-size:0.9375rem;font-weight:700;color:#1c1c1e;
                  font-family:'Lora',Georgia,serif;line-height:1.3;"></p>
              </div>
              <div style="display:flex;align-items:center;gap:0.5rem;flex-shrink:0;margin-top:0.1rem;">
                <a id="rp-link" href=""
                  style="font-size:0.6875rem;font-family:system-ui,sans-serif;
                  color:#1a2744;font-weight:600;text-decoration:none;
                  border:1px solid rgba(26,39,68,0.3);padding:0.25rem 0.5rem;
                  border-radius:0.25rem;white-space:nowrap;transition:background 0.12s;"
                  aria-label="Open full rule page">
                  Full rule ↗
                </a>
                <button id="rp-close" type="button" aria-label="Close reference panel"
                  style="font-size:1.125rem;color:#6b7280;background:none;border:none;
                  cursor:pointer;padding:0.125rem 0.375rem;line-height:1;transition:color 0.12s;
                  border-radius:0.25rem;">✕</button>
              </div>
            </div>
            <div id="rp-body" style="padding:1.25rem 1.5rem 3rem;"></div>
          `;
          document.body.appendChild(panel);

          const rpClose = document.getElementById('rp-close') as HTMLButtonElement;
          const rpLink  = document.getElementById('rp-link') as HTMLAnchorElement;
          const rpTitle = document.getElementById('rp-title')!;
          const rpLabel = document.getElementById('rp-ruleset')!;
          const rpBody  = document.getElementById('rp-body')!;

          let panelTrigger: HTMLElement | null = null;

          function closePanel() {
            panel.style.display = 'none';
            srAnnounce.textContent = 'Reference panel closed';
            panelTrigger?.focus(); // return focus to the link that opened the panel
            panelTrigger = null;
          }
          rpClose.addEventListener('click', closePanel);
          document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && panel.style.display !== 'none') closePanel();

            // Focus trap: keep Tab within the reference panel while it's open
            if (e.key === 'Tab' && panel.style.display !== 'none') {
              const focusable = Array.from(
                panel.querySelectorAll('a, button, input, [tabindex="0"]')
              ).filter((el) => !(el as HTMLElement).hasAttribute('disabled') && (el as HTMLElement).offsetParent !== null) as HTMLElement[];
              if (focusable.length === 0) return;
              const first = focusable[0];
              const last = focusable[focusable.length - 1];
              if (e.shiftKey) {
                if (document.activeElement === first) {
                  e.preventDefault();
                  last.focus();
                }
              } else {
                if (document.activeElement === last) {
                  e.preventDefault();
                  first.focus();
                }
              }
            }
          });
          // Close when the user clicks anywhere outside the panel (back to main content)
          document.addEventListener('click', (e) => {
            if (panel.style.display === 'none') return;
            const target = e.target as Element;
            if (!panel.contains(target) && !target.closest('.rule-xref')) closePanel();
          });

          // Convert subsection string "(a)(1)" → anchor "#a-1"
          function toAnchor(subs: string): string {
            const parts = [...subs.matchAll(/\(([^)]+)\)/g)].map(m => m[1]);
            return parts.length ? '#' + parts.join('-') : '';
          }

          // ── Fetch + display a referenced rule ──────────────────────────
          async function openPanel(ruleNum: string, anchor: string, trigger: HTMLElement, xrRuleset?: string) {
            panelTrigger = trigger;
            const targetRS = xrRuleset ?? ruleset;
            const url = `/${targetRS}/${ruleNum}/`;
            rpLink.href = url;
            rpLabel.textContent = RULESETS[targetRS] ?? '';
            rpTitle.textContent = `Rule ${ruleNum}`;
            rpBody.innerHTML =
              '<p style="color:#6b7280;font-family:system-ui,sans-serif;font-size:0.875rem;padding:0.5rem 0;">Loading…</p>';
            panel.style.display = 'block';
            panel.scrollTop = 0;
            requestAnimationFrame(() => rpClose.focus()); // move focus into panel
            srAnnounce.textContent = `Opening Rule ${ruleNum}`;

            try {
              const res = await fetch(url);
              if (!res.ok) throw new Error(String(res.status));
              const html = await res.text();
              const doc = new DOMParser().parseFromString(html, 'text/html');
              const h1 = doc.querySelector('article h1');
              if (h1) rpTitle.textContent = h1.textContent?.trim() ?? `Rule ${ruleNum}`;
              const body = doc.querySelector('.rule-body');
              rpBody.innerHTML = '';
              if (body) {
                // Prefix all IDs to avoid conflicts with main page element IDs
                body.querySelectorAll('[id]').forEach(el => { el.id = 'rp-' + el.id; });
                rpBody.appendChild(document.adoptNode(body));
                // Scroll to subsection, offset below the sticky header
                if (anchor) {
                  const anchorId = 'rp-' + anchor.slice(1); // "#a-1" → "rp-a-1"
                  requestAnimationFrame(() => {
                    const target = rpBody.querySelector<HTMLElement>(`#${CSS.escape(anchorId)}`);
                    if (target) {
                      const headerHeight = document.getElementById('rp-header')?.offsetHeight ?? 56;
                      const panelTop = panel.getBoundingClientRect().top;
                      const targetTop = target.getBoundingClientRect().top;
                      // panel.scrollTop is 0 here (reset on open), so this positions target
                      // just below the sticky header with a little breathing room.
                      panel.scrollTop = Math.max(0, targetTop - panelTop - headerHeight - 16);
                      // Blink the target section to draw the user's eye to it
                      target.classList.remove('rp-highlight'); // reset if already animating
                      void target.offsetWidth;                 // force reflow to restart animation
                      target.classList.add('rp-highlight');
                      target.addEventListener('animationend', () => {
                        target.classList.remove('rp-highlight');
                      }, { once: true });
                    }
                  });
                }
              } else {
                rpBody.innerHTML =
                  '<p style="color:#6b7280;font-family:system-ui,sans-serif;font-size:0.875rem;">Content not available.</p>';
              }
              srAnnounce.textContent = `Rule ${ruleNum} loaded`;
            } catch {
              rpBody.innerHTML =
                '<p style="color:#6b7280;font-family:system-ui,sans-serif;font-size:0.875rem;">Could not load rule. Try opening the full rule page.</p>';
              srAnnounce.textContent = `Could not load Rule ${ruleNum}`;
            }
          }

          // ── Auto-link rule citations in rule text ──────────────────────
          // Handles two forms:
          //   "Rule N(a)(b)"           → same-ruleset link  (e.g. /civil/26/#a-1)
          //   "Fed. R. Civ. P. N(a)"  → cross-ruleset link (e.g. /civil/4/#e)
          const RULE_RE = /\bRule\s+(\d+(?:\.\d+)?)\s*((?:\([^)]+\))*)/g;

          // Bluebook citation regex: "Fed. R. Xxx. P. N(a)(b)"
          const BLUEBOOK_RE = /\bFed\.\s+R\.\s+(Civ\.\s+P\.|Crim\.\s+P\.|App\.\s+P\.|Evid\.|Bankr\.\s+P\.)\s+(\d+(?:\.\d+)?)\s*((?:\([^)]+\))*)/g;
          const BLUEBOOK_RULESET: Record<string, string> = {
            'Civ. P.':   'civil',
            'Crim. P.':  'criminal',
            'App. P.':   'appellate',
            'Evid.':     'evidence',
            'Bankr. P.': 'bankruptcy',
          };

          function linkify(node: Node) {
            if (node.nodeType === Node.TEXT_NODE) {
              const text = node.textContent ?? '';
              RULE_RE.lastIndex = 0;
              BLUEBOOK_RE.lastIndex = 0;
              if (!RULE_RE.test(text) && !BLUEBOOK_RE.test(text)) return;

              // Apply Bluebook replacements first (more specific pattern)
              BLUEBOOK_RE.lastIndex = 0;
              let replaced = text.replace(BLUEBOOK_RE, (match, abbrev, num, subs) => {
                const key = abbrev.trim().replace(/\s+/g, ' ');
                const targetRS = BLUEBOOK_RULESET[key] ?? ruleset;
                const anchor = toAnchor(subs ?? '');
                const href = `/${targetRS}/${num}/${anchor}`;
                const safeMatch = match.replace(/"/g, '&quot;');
                return `<a href="${href}" class="rule-xref" data-rule="${num}" data-anchor="${anchor}"` +
                  ` data-xref-ruleset="${targetRS}" aria-label="${safeMatch}: view in side panel">${match}</a>`;
              });

              // Then apply same-ruleset "Rule N" replacements
              RULE_RE.lastIndex = 0;
              replaced = replaced.replace(RULE_RE, (match, num, subs) => {
                const anchor = toAnchor(subs ?? '');
                const href = `/${ruleset}/${num}/${anchor}`;
                return `<a href="${href}" class="rule-xref" data-rule="${num}" data-anchor="${anchor}"` +
                  ` aria-label="${match}: view in side panel">${match}</a>`;
              });

              const wrap = document.createElement('span');
              wrap.innerHTML = replaced;
              node.parentNode?.replaceChild(wrap, node);
            } else if (
              node.nodeType === Node.ELEMENT_NODE &&
              !(node as Element).matches('a, script, style, code, pre')
            ) {
              Array.from(node.childNodes).forEach(linkify);
            }
          }
          linkify(ruleBody);

          // ── "Contains Deadlines" badge → click to blink + highlight all deadlines ──
          // Finds paragraphs with time-period language, marks them with .deadline-para,
          // and wires the badge to toggle a persistent faint gold highlight on all of them.
          const deadlineBadge = Array.from(
            document.querySelectorAll<HTMLElement>('article header span')
          ).find(el => el.textContent?.trim() === 'Contains Deadlines');

          if (deadlineBadge) {
            const DEADLINE_RE =
              /\b\d+\s*(?:calendar\s+|business\s+|court\s+)?(?:days?|hours?|months?|years?|weeks?)\b(?!\s+(?:old\b|of\s+age))/i;
            const deadlineParas: HTMLElement[] = [];

            for (const p of ruleBody.querySelectorAll<HTMLElement>('p')) {
              if (DEADLINE_RE.test(p.textContent ?? '')) {
                p.classList.add('deadline-para');
                deadlineParas.push(p);
              }
            }

            // If no deadline paragraphs found, the badge is a scraper false positive —
            // hide it so users aren't misled (e.g. "within 100 miles" triggering detection).
            if (!deadlineParas.length) {
              deadlineBadge.style.display = 'none';
            } else {
              deadlineBadge.style.cursor = 'pointer';
              deadlineBadge.setAttribute('role', 'button');
              deadlineBadge.setAttribute('tabindex', '0');
              deadlineBadge.setAttribute('aria-label', 'Highlight deadlines in this rule');
              deadlineBadge.title = 'Click to highlight deadlines';

              let deadlinesActive = false;

              const toggleDeadlines = () => {
                deadlinesActive = !deadlinesActive;
                if (deadlinesActive) {
                  // Blink all deadline paragraphs and let the animation settle
                  // to a faint persistent gold (animation-fill-mode: forwards).
                  deadlineParas.forEach(p => {
                    p.classList.remove('deadline-active');
                    void p.offsetWidth; // force reflow to restart animation
                    p.classList.add('deadline-active');
                  });
                  // Scroll to first deadline
                  const dlMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches ? 'auto' : 'smooth';
                  deadlineParas[0].scrollIntoView({ block: 'start', behavior: dlMotion as ScrollBehavior });
                  const headerEl = document.querySelector('header.sticky');
                  const offset = headerEl?.getBoundingClientRect().bottom ?? 0;
                  if (offset > 0) {
                    setTimeout(() => window.scrollBy({ top: -offset - 8, behavior: dlMotion as ScrollBehavior }), 300);
                  }
                } else {
                  // Remove highlight — class removal drops the fill-mode background
                  deadlineParas.forEach(p => p.classList.remove('deadline-active'));
                }
              };

              deadlineBadge.addEventListener('click', toggleDeadlines);
              deadlineBadge.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggleDeadlines(); }
              });
            }
          }

          // On desktop: open side panel. On mobile: follow the href normally.
          ruleBody.addEventListener('click', (e) => {
            if (window.innerWidth < 768) return;
            const link = (e.target as Element).closest<HTMLAnchorElement>('.rule-xref');
            if (!link) return;
            e.preventDefault();
            openPanel(link.dataset.rule!, link.dataset.anchor ?? '', link, link.dataset.xrefRuleset);
          });
        }
      }
    </script>

    {!noSidebar && (
      <script is:inline>
        const toggle = document.getElementById('sidebar-toggle');
        const sidebar = document.getElementById('rule-sidebar');
        const overlay = document.getElementById('sidebar-overlay');

        function openSidebar() {
          sidebar.classList.remove('-translate-x-full');
          overlay.classList.remove('hidden');
          toggle.setAttribute('aria-label', 'Close rule navigation');
          toggle.setAttribute('aria-expanded', 'true');
          document.body.style.overflow = 'hidden';
          // Move focus into sidebar
          const firstLink = sidebar.querySelector('a, button, [tabindex="0"]');
          if (firstLink) firstLink.focus();
        }

        function closeSidebar() {
          sidebar.classList.add('-translate-x-full');
          overlay.classList.add('hidden');
          toggle.setAttribute('aria-label', 'Open rule navigation');
          toggle.setAttribute('aria-expanded', 'false');
          document.body.style.overflow = '';
          // Return focus to toggle
          toggle.focus();
        }

        toggle.addEventListener('click', () => {
          toggle.getAttribute('aria-expanded') === 'true' ? closeSidebar() : openSidebar();
        });
        overlay.addEventListener('click', closeSidebar);

        // Auto-close sidebar when a rule link is tapped on mobile
        sidebar.querySelectorAll('a').forEach((link) => {
          link.addEventListener('click', () => {
            if (window.innerWidth < 768) closeSidebar();
          });
        });

        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') closeSidebar();

          // Focus trap: when sidebar is open, keep Tab within sidebar elements
          if (e.key === 'Tab' && toggle.getAttribute('aria-expanded') === 'true') {
            const focusable = Array.from(
              sidebar.querySelectorAll('a, button, input, [tabindex="0"]')
            ).filter((el) => !el.hasAttribute('disabled') && el.offsetParent !== null);
            if (focusable.length === 0) return;
            const first = focusable[0];
            const last = focusable[focusable.length - 1];
            if (e.shiftKey) {
              if (document.activeElement === first) {
                e.preventDefault();
                last.focus();
              }
            } else {
              if (document.activeElement === last) {
                e.preventDefault();
                first.focus();
              }
            }
          }
        });
      </script>
    )}
  </body>
</html>
